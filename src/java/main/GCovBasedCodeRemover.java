package edu.gatech.cc.debcov;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.io.File;
import org.apache.commons.io.FileUtils;

public class GCovBasedCodeRemover
{
    /* codef is the source code to be shrinked.
       linef is a file generated by applying line-position printer to codef. 
       gcovf is a file generated by applying gcov (with -i option) on codef. */
    /*
      It doesn't seem to change line numbers. That is, if a line is chosen 
      not to be removed, its line number will not change.
     */
    public static void main(String[] args) {
	File codef = new File(args[0]);
	File linef = new File(args[1]);
	File gcovf = new File(args[2]);
	System.out.println(getRemovedString(codef, linef, gcovf));
    }


    public static String getRemovedString(File codef, File linef, File gcovf) {
	List<String> gcov_lines = null;
	try { gcov_lines = FileUtils.readLines(gcovf, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
	if (gcov_lines == null) { return null; }
	
	Map<Integer,Integer> lcmap = getLineCountMap(gcov_lines);
	return getRemovedString(codef, linef, lcmap);
    }


    public static String getRemovedString(File codef, File linef, String gcovstr) {
	return getRemovedString(codef, linef, getLineCountMap(Arrays.asList(gcovstr.split("\n"))));
    }
    
    public static String getRemovedString(File codef, File linef, PathCoverage pcov) {
	return getRemovedString(codef, linef, pcov.getLineCountMap());
    }
    
    public static String getRemovedString(File codef, File linef, Map<Integer,Integer> lcmap) {
	Map<Integer, Integer> ffs_map = getStartEndLineMap(linef, "function");
	Map<Integer, Integer> sfs_map = getStartEndLineMap(linef, "statement");
	Map<Integer, String> spfs_map = getStartPropertyLineMap(linef, "statement"); //Starting line -> stmt type

	List<String> codef_lines = null;
	try { codef_lines = FileUtils.readLines(codef, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
	if (codef_lines == null) { return null; }
	int codef_lines_size = codef_lines.size();
	List<String> rslt_lines = new ArrayList<String>(codef_lines_size+1);


	//Either adding the original line or an empty line
	//For label stmt line, insert ";" at the end (compiling error otherwise)
	for (int i=1; i<=codef_lines_size; i++) {

	    if (lcmap.get(i) != null && lcmap.get(i).intValue() == 0) { //Non-covered

		if (ffs_map.get(i) != null) { //Is a function
		    int end = ffs_map.get(i).intValue(); //function-body end line
		    boolean full_removal = true;
		    for (int k=i; k<=end; k++) {
			if (lcmap.get(k) != null && lcmap.get(k) > 0) {
			    full_removal = false;
			    break;
			}
		    }
		    if (!full_removal) {
			rslt_lines.add(codef_lines.get(i-1));
			continue;
		    }

		    //For full removal
		    int start = -1; //function-body start line
		    for (int k=i; k<=end; k++) { //Looking for the function-body start line
			if (codef_lines.get(k-1).contains("{")) {
			    start = k;
			    break;
			}
		    }
		    
		    if (start != -1) {
			for (int k=i; k<start; k++) { //Add lines up to the function-body line
			    rslt_lines.add(codef_lines.get(k-1));
			}

			//For start line, add content up to "{"
			String start_line = codef_lines.get(start-1);
			rslt_lines.add(start_line.substring(0, start_line.indexOf("{")+1));

			//Add "" for function-body lines
			for (int k=start+1; k<end; k++) {
			    rslt_lines.add("");
			}

			//For end line, add content from "}" to line-end
			String end_line = codef_lines.get(end-1);
			rslt_lines.add(end_line.substring(end_line.indexOf("}")));

			//Reset i
			i = end;
		    }
		    else {
			//Wierd, no "{" found. Don't emptify the function body.
			rslt_lines.add(codef_lines.get(i-1));
		    }

		    continue;
		}

		//Don't remove compound line
		if ("compound".equals(spfs_map.get(i))) {
		    rslt_lines.add(codef_lines.get(i-1));
		    continue;
		}
		
		//Don't remove label line
		//(otherwise, we may have missing labels, see gcoverrorshooting-case0)
		//Need to however insert ";" at the end (compiling error otherwise)
		if ("label".equals(spfs_map.get(i))) {
		    rslt_lines.add(getSemiColonAugmentedLabelLine(codef_lines.get(i-1)));
		    continue;
		}

		//This line corresponds to ending line of function-def signature.
		//It's possible that function is not covered,
		//but its first line (of function-def signature)
		//is not marked by gcov (see gcoverrorshooting-case2).
		//(This is possible, as the function signature can span multiple lines.)
		//If so, we use fbcompound label to identify surrounding "{" and "}"
		//for function-body removal.
		if ("fbcompound".equals(spfs_map.get(i))) {
		    if (sfs_map.get(i) != null) {
			int j = sfs_map.get(i).intValue();
			boolean full_removal = true;
			for (int k=i; k<=j; k++) {
			    if (lcmap.get(k) != null && lcmap.get(k) > 0) { //Inner stmt covered!
				full_removal = false;
				break;
			    }
			}
			if (!full_removal) {
			    rslt_lines.add(codef_lines.get(i-1));
			    continue;
			}

			//For full removal
			for (int k=i; k<=j; k++) {
			    if (k == i) { //Removed code from "{" to line-end
				String oldline = codef_lines.get(k-1);
				rslt_lines.add(oldline.substring(0, oldline.indexOf("{")+1));
			    } 
			    else if (k == j) { //Removed code up to "}"
				String oldline = codef_lines.get(k-1);
				rslt_lines.add(oldline.substring(oldline.indexOf("}")));
			    } 
			    else { //Removed line
				rslt_lines.add("");
			    }
			}
			i = j; //Move cursor to the end of the function
		    }
		    else {
			rslt_lines.add(codef_lines.get(i-1));
		    }
		    continue;
		}
		
		//For statement line
		if (sfs_map.get(i) != null) {
		    int j = sfs_map.get(i).intValue(); //Ending line
		    boolean full_removal = true;
		    for (int k=i; k<=j; k++) {
			if (lcmap.get(k) != null && lcmap.get(k) > 0) { //Inner stmt covered!
			    full_removal = false;
			    break;
			}
		    }

		    if (full_removal) {
			for (int k=i; k<=j; k++) {
			    rslt_lines.add(""); //Remove the line
			}
			i = j; //Move cursor to the end of the stmt
		    }
		    else {
			//Do not remove the line
			rslt_lines.add(codef_lines.get(i-1));
		    }
		}

		else {
		    //Non-covered line not recorded in line file. Keep it.");
		    rslt_lines.add(codef_lines.get(i-1));
		}
	    }

	    else { //If code is covered, keep it.

		if ("label".equals(spfs_map.get(i))) {
		    //The reason why we add a ";" is because
		    //it is possible for llvm to flag a label line as COVERED
		    //but its labeled content as NON-COVERED. (Wierd, right?)
		    //In such case, compilation error can occur
		    //if removing the label content but keeping the label line.
		    rslt_lines.add(getSemiColonAugmentedLabelLine(codef_lines.get(i-1)));
		}
		else {
		    rslt_lines.add(codef_lines.get(i-1)); //Add the original line
		}
	    }
	}

	StringBuilder sb = null;
	for (String rslt_line : rslt_lines) {
	    if (sb == null) { sb = new StringBuilder(); }
	    else { sb.append("\n"); }
	    sb.append(rslt_line);
	}

	if (sb != null) { return sb.toString(); }
	else { return null; }
    }

    private static Map<Integer, Integer> getStartEndLineMap(File linef, String granu) {
	Map<Integer, Integer> lmap = new HashMap<Integer, Integer>();
	List<String> linef_lines = null;
	try { linef_lines = FileUtils.readLines(linef, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
	if (linef_lines == null) { return lmap; }

	for (String linef_line : linef_lines) {
	    linef_line = linef_line.trim();
	    String[] elems = null;
	    if (linef_line.startsWith(granu+":")) {
		elems = linef_line.substring((granu+":").length()).split(",");
	    }
	    else {
		continue;
	    }

	    int sl = Integer.parseInt(elems[0]);
	    int el = Integer.parseInt(elems[1]);
	    if (lmap.get(sl) == null) {
		lmap.put(sl, el);
	    }
	    else {
		//E.g., l0 has two ending lines l2 (compound) & l4 (if). We save l4 in the map.
		//if (c) { //l0
		//  s0;    //l1
		//} else { //l2
		//  s1;    //l3
		//}        //l4
		int el_curr = lmap.get(sl).intValue();
		if (el > el_curr) { lmap.put(sl, el); }
	    }
	}
	
	return lmap;
    }

    private static Map<Integer, String> getStartPropertyLineMap(File linef, String granu) {
	Map<Integer, String> lmap = new HashMap<Integer, String>();
	List<String> linef_lines = null;
        try { linef_lines = FileUtils.readLines(linef, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
        if (linef_lines == null) { return lmap; }

        for (String linef_line : linef_lines) {
            linef_line = linef_line.trim();
            String[] elems = null;
            if (linef_line.startsWith(granu+":")) {
                elems = linef_line.substring((granu+":").length()).split(",");
            }
            else {
                continue;
            }

	    int sl = Integer.parseInt(elems[0]);
	    if (elems.length > 2) {
		if (lmap.get(sl) == null) {
		    lmap.put(sl, elems[2]);
		}
	    }
	}

	return lmap;
    }

    /* Note that this map does not include non-code lines (led by "-") determined by gcov. */
    private static Map<Integer,Integer> getLineCountMap(List<String> gcov_lines) {
	Map<Integer,Integer> lcmap = new HashMap<Integer,Integer>();
	for (String gcov_line : gcov_lines) {
	    gcov_line = gcov_line.trim();
            if (gcov_line.startsWith("lcount:")) {
		String[] elems = gcov_line.substring(gcov_line.indexOf(":")+1).split(",");
		lcmap.put(Integer.parseInt(elems[0]), Integer.parseInt(elems[1]));
	    }
	}
	return lcmap;
    }
    
    private static Set<Integer> getNonCoveredLines(List<String> gcov_lines) {
	Set<Integer> lset = new HashSet<Integer>();
	for (String gcov_line : gcov_lines) {
	    gcov_line = gcov_line.trim();
	    if (gcov_line.startsWith("lcount:") &&
		gcov_line.endsWith(",0")) {
		String lno = gcov_line.substring(gcov_line.indexOf(":")+1, gcov_line.indexOf(","));
		lset.add(Integer.parseInt(lno));
	    }
	}
	return lset;
    }

    private static String getSemiColonAugmentedLabelLine(String oldline) {
	int ci0 = oldline.indexOf("//");
	int ci1 = oldline.indexOf("/*");
	int ci = -1;
	String newline = null;
	if (ci0 != -1 && ci1 == -1) { ci = ci0; }
	else if (ci0 == -1 && ci1 != -1) { ci = ci1; }
	else if (ci0 != -1 && ci1 != -1) { ci = (ci0 < ci1) ? ci0 : ci1; }
	if (ci != -1) {
	    newline = oldline.substring(0, ci) + ";" + oldline.substring(ci);
	}
	else {
	    newline = oldline + ";";
	}
	return newline;
    }
}
